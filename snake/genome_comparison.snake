from snake.misc import alias_recipe, alias_fmt, curl_recipe, curl_unzip_recipe

# Compare my MAGs to reference genomes (e.g. Ormerod2016)

# {{{1 Metadata

config['ref_genomes'] = \
        [ 'GP1'
        , 'GP2'
        , 'GP3'
        , 'GP4'
        , 'H1'
        , 'H10'
        , 'H2'
        , 'H3'
        , 'H4'
        , 'H5'
        , 'H6'
        , 'H7'
        , 'H8'
        , 'H9'
        , 'K1'
        , 'K10'
        , 'M1'
        , 'M10'
        , 'M11'
        , 'M12'
        , 'M13'
        , 'M14'
        , 'M2'
        , 'M3'
        , 'M5'
        , 'M6'
        , 'M7'
        , 'M8'
        , 'M9'
        , 'Homeothermus_arabinoxylanisolvens'
        , 'Muribaculum_intestinale_yl27'
        ]

config['sra'] = \
        {
        'GP1'                               : 'DAAI01000000',
        'GP2'                               : 'DAAJ01000000',
        'GP3'                               : 'DAAK01000000',
        'GP4'                               : 'DAAL01000000',
        'H1'                                : 'DAAM01000000',
        'H10'                               : 'DAAV01000000',
        'H2'                                : 'DAAO01000000',
        'H3'                                : 'DAAN01000000',
        'H4'                                : 'DAAP01000000',
        'H5'                                : 'DAAQ01000000',
        'H6'                                : 'DAAR01000000',
        'H7'                                : 'DAAS01000000',
        'H8'                                : 'DAAT01000000',
        'H9'                                : 'DAAU01000000',
        'K1'                                : 'LUJZ01000000',
        'K10'                               : 'LUKA01000000',
        'M1'                                : 'LUJL01000000',
        'M10'                               : 'LUJU01000000',
        'M11'                               : 'LUJV01000000',
        'M12'                               : 'LUJW01000000',
        'M13'                               : 'LUJX01000000',
        'M14'                               : 'LUJY01000000',
        'M2'                                : 'LUJM01000000',
        'M3'                                : 'LUJN01000000',
        'M5'                                : 'LUJP01000000',
        'M6'                                : 'LUJQ01000000',
        'M7'                                : 'LUJR01000000',
        'M8'                                : 'LUJS01000000',
        'M9'                                : 'LUJT01000000',
        'Homeothermus_arabinoxylanisolvens' : 'LUJO01000000',
        }

config['mags'] = \
        {
        'Otu0003'     : {'taxon' : 'Sphingopyxis alaskensis'},
        'Otu0002'     : {'taxon' : 'Lactobacillus johnsonii'},
        'Otu0001'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0007'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0009'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0005'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0004'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0049'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0017'     : {'taxon' : 'Muribaculaceae sp.'},
        'Otu0015'     : {'taxon' : 'Lachnospiraceae sp.'},
        'Otu0025'     : {'taxon' : 'Lachnospiraceae sp.'},
        'Otu0032'     : {'taxon' : 'Lachnospiraceae sp.'},
        'Otu0012'     : {'taxon' : 'Ruminiclostridium sp.'},
        'Otu0006'     : {'taxon' : 'Turicibacter sp.'},
        'Otu0020'     : {'taxon' : 'Ruminococcaceae sp.'},
        'Otu0035'     : {'taxon' : 'Ruminococcaceae sp.'},
        'Otu0058'     : {'taxon' : 'Mollicutes sp.'},
        'Otu0041'     : {'taxon' : 'Bacteroides sp.'},
        }

config['gene_to_search_string'] = \
    {'rpoB': 'DNA-directed RNA polymerase subunit beta$',
     'gyrB': 'DNA gyrase subunit B$',
     'rpoA': 'DNA-directed RNA polymerase subunit alpha$',
     'rpoC': 'DNA-directed RNA polymerase subunit beta\'$',
     'lepA': 'Elongation factor 4$',
     'rrnS': '16S ribosomal RNA$'}

config['gene_to_hmm'] = \
    {'rpoB': 'TIGR02013',
     'gyrB': 'TIGR01059',
     'rpoA': 'TIGR02027',
     'CBM58': 'CBM58',
     'GH13': 'GH13',
     'rpoC': 'TIGR02386',
     'lepA': 'TIGR01393',
     'mmdA': 'TIGR01117',
     }

config['genome_group'] = \
        { 'muri':
             { 'mags': [ 'Otu0001_vA'
                       , 'Otu0001_vB'
                       , 'Otu0001_vC'
                       , 'Otu0004_vA'
                       , 'Otu0005_vA'
                       , 'Otu0007_vA'
                       , 'Otu0009_vA'
                       , 'Otu0017_vA'
                       , 'Otu0049_vA'
                       ]
             , 'refs': [ 'GP1'
                       , 'GP2'
                       , 'GP3'
                       , 'GP4'
                       , 'H1'
                       , 'H10'
                       , 'H2'
                       , 'H3'
                       , 'H4'
                       , 'H5'
                       , 'H6'
                       , 'H7'
                       , 'H8'
                       , 'H9'
                       , 'K1'
                       , 'K10'
                       , 'M1'
                       , 'M10'
                       , 'M11'
                       , 'M12'
                       , 'M13'
                       , 'M14'
                       , 'M2'
                       , 'M3'
                       , 'M5'
                       , 'M6'
                       , 'M7'
                       , 'M8'
                       , 'M9'
                       , 'Homeothermus_arabinoxylanisolvens'
                       , 'Muribaculum_intestinale_yl27'
                       , 'Bacteroides_thetaiotaomicron_VPI5482'  # Outgroup
                       ]
             }
        }

# {{{1 Download and link data

# This is intended for Ormerod MAGs.
rule alias_sra_genomes:
    output: 'data/ref.mags/{mag_id}.g.fn'
    input: lambda wildcards: 'raw/sra/{accession}.fn'.format(accession=config['sra'][wildcards.mag_id])
    wildcard_constraints:
        mag_id='[^.]+'
    shell: "ln -rs {input} {output}"

rule download_m_intestinale_genome:
    output: 'raw/ref/Muribaculum_intestinale_yl27.fn'
    params:
        url='ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/002/201/515/GCA_002201515.1_ASM220151v1/GCA_002201515.1_ASM220151v1_genomic.fna.gz'
    shell: curl_unzip_recipe

rule alias_m_intestinale_genome:
    output: 'data/ref.mags/Muribaculum_intestinale_yl27.g.fn'
    input: 'raw/ref/Muribaculum_intestinale_yl27.fn'
    shell: "ln -rs {input} {output}"

ruleorder: alias_m_intestinale_genome > alias_sra_genomes

rule download_btheta_genome:
    output: 'raw/ref/Bacteroides_thetaiotaomicron_VPI5482.fn'
    params:
        url='https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=AE015928.1&rettype=fasta&retmode=text'
    shell: curl_recipe

rule alias_btheta_genome:
    output: 'data/ref.mags/Bacteroides_thetaiotaomicron_VPI5482.g.fn'
    input: 'raw/ref/Bacteroides_thetaiotaomicron_VPI5482.fn'
    shell: "ln -rs {input} {output}"

ruleorder: alias_btheta_genome > alias_sra_genomes

localrules: download_btheta_genome, download_m_intestinale_genome,
            alias_sra_genomes, alias_btheta_genome,
            alias_m_intestinale_genome

# {{{1 Compile data

rule full_genomes_group_quast_result:
    output:
        dir="data/{group}.a.mags.{genomes}.g.{proc}.quast.d",
        report="data/{group}.a.mags.{genomes}.g.{proc}.quast.tsv",
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags/{mag_stem}.g.{wildcards.proc}.fn'
                                for mag_stem in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags/{ref_stem}.g.fn'
                                for ref_stem in config['genome_group'][wildcards.genomes]['refs']],
    params:
        labels=lambda wildcards: ', '.join(list(config['genome_group'][wildcards.genomes]['mags']) +
                                           list(config['genome_group'][wildcards.genomes]['refs']))
    shell:
        """
        quast.py --threads={threads} --min-contig 0 --output-dir {output.dir} --labels "{params.labels}" {input.mags} {input.refs}
        cp {output.dir}/transposed_report.tsv {output.report}
        """

# This is then used by the CheckM recipe to get a summary of completeness/contamination
rule make_genome_group_dir:
    output: 'data/{group}.a.mags.{genomes}.g.{proc}.genome_group.d'
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags/{mag}.g.{wildcards.proc}.fn'
                                for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags/{ref}.g.fn'
                                for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        """
        rm -rf {output}
        mkdir -p {output}
        for genome in {input.mags};
        do
            ln -rs $genome {output}/$(basename --suffix .g.{wildcards.proc}.fn $genome).fn
        done
        for genome in {input.refs};
        do
            ln -rs $genome {output}/$(basename $genome)
        done
        """

rule combine_annotation_summaries:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.prokka.summary.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.prokka.summary.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.prokka.summary.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        r"""
        (
            printf "mag_id\tstatistic\tvalue\n"
            for file in {input.mags}; do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.{wildcards.proc}.prokka.summary.tsv $file) '{{print mag_id, $0}}' $file
            done
            for file in {input.refs}; do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.prokka.summary.tsv $file) '{{print mag_id, $0}}' $file
            done
        ) | python3 -c '
import pandas as pd
import sys

data = pd.read_table(sys.stdin, index_col=["mag_id", "statistic"])["value"].unstack("statistic")
data.to_csv(sys.stdout, sep="\t")
                        ' > {output}
        """

rule compile_genomes_group_stats_table:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.genome_stats.tsv"
    input:
        checkm="data/{group}.a.mags.{genomes}.g.{proc}.genome_group.checkm_details.tsv",
        quast="data/{group}.a.mags.{genomes}.g.{proc}.quast.tsv",
        annot="data/{group}.a.mags.{genomes}.g.{proc}.prokka.summary.tsv"
    shell:
        """
        tmp_checkm=$(mktemp)
        tmp_quast=$(mktemp)
        tmp_annot=$(mktemp)
        tmp_unord=$(mktemp)
        sed '1,1s:Bin Id:mag_id:' {input.checkm} | sort -k1,1 > $tmp_checkm
        sed '1,1s:Assembly:mag_id:' {input.quast} | sort -k1,1 > $tmp_quast
        sort -k1,1 {input.annot} > $tmp_annot
        join -t '\t' $tmp_checkm <(join -t '\t' $tmp_quast $tmp_annot) > $tmp_unord
        grep 'mag_id' $tmp_unord > {output}
        grep -v 'mag_id' $tmp_unord >> {output}
        """

rule compile_gene_by_genome_tables:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.gene_genome_map.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.prokka-annot.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.prokka-annot.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        r"""
        (
            for file in {input.mags}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.{wildcards.proc}.prokka-annot.tsv $file) 'NR > 1 {{print mag_id, $1}}' $file
            done
            for file in {input.refs}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.prokka-annot.tsv $file) 'NR > 1 {{print mag_id, $1}}' $file
            done
        ) > {output}
        """

rule compile_sequence_by_genome_tables:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.sequence_to_genome.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags/{mag}.g.{wildcards.proc}.sequence.list'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags/{ref}.g.sequence.list'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        r"""
        (
            for file in {input.mags}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.{wildcards.proc}.sequence.list $file) '{{print $1, mag_id}}' $file
            done
            for file in {input.refs}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.sequence.list $file) '{{print $1, mag_id}}' $file
            done
        ) > {output}
        """

rule compile_feature_details:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.feature_details.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.feature_details.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.feature_details.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        """
        cat {input} > {output}
        """

ruleorder: compile_feature_details > extract_feature_details

rule combine_feature_tables:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.features.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.features.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.features.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        r"""
        cat {input} > {output}
        """

ruleorder: combine_feature_tables > parse_feature_table


rule combine_annotations:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.{annot}-annot.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.{wildcards.annot}.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.{wildcards.annot}.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    wildcard_constraints:
        annot=one_word_wc_constraint
    shell:
        """
        cat {input} > {output}
        """

rule compile_genome_sequences:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.fn"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags/{mag}.g.{wildcards.proc}.fn'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags/{ref}.g.fn'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    wildcard_constraints:
        annot=one_word_wc_constraint
    shell:
        """
        cat {input} > {output}
        """

rule compile_cds:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.cds.fa"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.cds.fa'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.cds.fa'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    wildcard_constraints:
        annot=one_word_wc_constraint
    shell:
        """
        cat {input} > {output}
        """

ruleorder: compile_cds > annotate_mag

rule combine_prokka_annotations:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.prokka-annot.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.prokka-annot.tsv'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.prokka-annot.tsv'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        """
        for file in {input}
        do
            sed '1,1d' $file
        done > {output}
        """

ruleorder: combine_prokka_annotations > combine_annotations

rule combine_minpath_results:
    output:
        "data/{group}.a.mags.{genomes}.g.{proc}.ec-minpath.count.tsv"
    input:
        mags=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{mag}.g.{wildcards.proc}.ec-minpath.list'
                                     for mag in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [f'data/ref.mags.annot/{ref}.g.ec-minpath.list'
                                     for ref in config['genome_group'][wildcards.genomes]['refs']],
    wildcard_constraints:
        annot=one_word_wc_constraint
    shell:
        r"""
        (
            for file in {input.mags}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .g.{wildcards.proc}.ec-minpath.list $file) '{{print mag_id, $1, 1}}' $file
            done
            for file in {input.refs}
            do
                awk -v OFS='\t' -v mag_id=$(basename --suffix .ec-minpath.list $file) '{{print mag_id, $1, 1}}' $file
            done
        ) > {output}
        """

# {{{1 Full-genome phylogenetics

rule pick_phylogenetic_marker_genes:
    output:
        dir="data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.d",
        # .../markers.list  # List of shared single-copy markers
        # .../GENE_NAME.fa  # Amino-acid sequences to be aligned for each gene
        # .../genome_to_cds.tsv  # Mapping from sequences to genomes
    input:
        script="scripts/pick_marker_genes.py",
        mags_hits=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.Pfam-hits.hmmer-tc.tsv'
                                     for g in config['genome_group'][wildcards.genomes]['mags']],
        refs_hits=lambda wildcards: [f'data/ref.mags.annot/{g}.g.cds.Pfam-hits.hmmer-tc.tsv'
                                     for g in config['genome_group'][wildcards.genomes]['refs']],
        mags_seqs=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.fa'
                                     for g in config['genome_group'][wildcards.genomes]['mags']],
        refs_seqs=lambda wildcards: [f'data/ref.mags.annot/{g}.g.cds.fa'
                                     for g in config['genome_group'][wildcards.genomes]['refs']],
    params:
        mags=lambda wildcards: [(f'{g}:data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.Pfam-hits.hmmer-tc.tsv'
                                 f':data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.fa')
                                for g in config['genome_group'][wildcards.genomes]['mags']],
        refs=lambda wildcards: [(f'{g}:data/ref.mags.annot/{g}.g.cds.Pfam-hits.hmmer-tc.tsv'
                                 f':data/ref.mags.annot/{g}.g.cds.fa')
                                for g in config['genome_group'][wildcards.genomes]['refs']],
    shell:
        """
        rm -rf {output.dir}
        mkdir -p {output.dir}
        {input.script} --fasta-output-template '{output}/{{}}.fa' \
                --tsv-output '{output.dir}/gene_genome_map.tsv' \
                --list-output '{output.dir}/genes.list' \
                {params.mags} {params.refs}
        """

rule align_phylogenetic_marker_genes:
    output:
        dir="data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.align.d",
    input:
        squeeze_script="scripts/squeeze_alignment.py",
        dir="data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.d",
        hmm="ref/hmm/Pfam.hmm",
    shell:
        """
        rm -rf {output.dir}
        mkdir -p {output.dir}
        while read hmm
        do
            echo $hmm
            # Grab the correct HMMs from {input.hmm}
            hmmfetch {input.hmm} $hmm > {output.dir}/$hmm.hmm
            # hmmalign each fasta file
            hmmalign --amino --trim --informat fasta {output.dir}/$hmm.hmm {input.dir}/$hmm.fa \
                    | convert -f stockholm -t fasta > {output.dir}/$hmm.afa
            # Trim off the unaligned nucleotides (see scripts/squeeze_alignment.py) for each
            {input.squeeze_script} '-.*abcdefghijklmnopqrstuvwxyz' < {output.dir}/$hmm.afa > {output.dir}/$hmm.sqz.afa
        done < {input.dir}/genes.list
        """

rule concatenate_marker_gene_alignments:
    output: "data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.afa",
    input:
        concat_script="scripts/concat_alignments.py",
        search_dir="data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.d",
        align_dir="data/{group}.a.mags.{genomes}.g.{proc}.marker_genes.align.d",
    shell:
        """
        # Concatenate the alignments {input.concat_script}
        {input.concat_script} {input.search_dir}/gene_genome_map.tsv \
                $(for hmm in `cat {input.search_dir}/genes.list`
                  do
                      echo $hmm:{input.align_dir}/$hmm.sqz.afa
                  done
                 ) \
                > {output}
        """

# {{{1 CAZy Annotations
# TODO: Split this into two recipes.
rule compile_cazy_hits:
    output:
        fasta="data/{group}.a.mags.{genomes}.g.{proc}.dbCAN-hits.fa",
        tsv="data/{group}.a.mags.{genomes}.g.{proc}.dbCAN-hits.gene_genome_map.tsv"
    input:
        mags_hits=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.dbCAN-hits.hmmer-tc.tsv'
                                     for g in config['genome_group'][wildcards.genomes]['mags']],
        refs_hits=lambda wildcards: [f'data/ref.mags.annot/{g}.g.cds.dbCAN-hits.hmmer-tc.tsv'
                                     for g in config['genome_group'][wildcards.genomes]['refs']],
        mags_seqs=lambda wildcards: [f'data/{wildcards.group}.a.mags.annot/{g}.g.{wildcards.proc}.cds.dbCAN-hits.fa'
                                     for g in config['genome_group'][wildcards.genomes]['mags']],
        refs_seqs=lambda wildcards: [f'data/ref.mags.annot/{g}.g.cds.dbCAN-hits.fa'
                                     for g in config['genome_group'][wildcards.genomes]['refs']],
    params:
    shell:
        r"""
        cat {input.mags_seqs} {input.refs_seqs} > {output.fasta}
        for hits in {input.mags_hits}
        do
            genome_name=$(basename --suffix .g.{wildcards.proc}.cds.dbCAN-hits.hmmer-tc.tsv $hits)
            awk -v g="$genome_name" -v OFS='\t' 'NR!=1{{print g,$1}}' $hits
        done > {output.tsv}
        for hits in {input.refs_hits}
        do
            genome_name=$(basename --suffix .cds.dbCAN-hits.hmmer-tc.tsv $hits)
            awk -v g="$genome_name" -v OFS='\t' 'NR!=1{{print g,$1}}' $hits
        done >> {output.tsv}
        """


ruleorder: compile_cazy_hits > compile_gene_by_genome_tables
